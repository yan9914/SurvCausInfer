n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts)-1) {
return((ts[Y[,2] == 1,i]))
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(tmp1)
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("lambda1", "p1", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0("lambda",i), paste0("p",i), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
return(ll(par))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(starts_with(c("lambda", "p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts)-1) {
return((ts[Y[,2] == 1,1]))
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(tmp1)
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("lambda1", "p1", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0("lambda",i), paste0("p",i), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
return(ll(par))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(starts_with(c("lambda", "p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("lambda1", "p1", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0("lambda",i), paste0("p",i), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
return(ll(par))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(starts_with(c("lambda", "p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
ll(c(0,0,0,0,0,0))
ll <- function(par) {
lambda <- exp(par[1])
p1 <- exp(par[2])
alpha <- exp(par[3])
p2 <- exp(par[4])
b1 <- par[5]
b2 <- par[6]
# lambda <- x[1]
# p1 <- x[2]
# alpha <- x[3]
# p2 <- x[4]
-with(data, sum(log(lambda * p1 * time[status == 1] ^ (p1-1) * exp(x[status == 1] * b1) + alpha * p2 * (d_age[status == 1]) ^ (p2-1) * exp(x[status == 1] * b2))) - lambda * sum(time ^ p1 * exp(x * b1)) - alpha * sum((d_age ^ p2 - age ^ p2) * exp(x * b2)))
}
ll(c(0,0,0,0,0,0))
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("lambda1", "p1", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0("lambda",i), paste0("p",i), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(starts_with(c("lambda", "p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, lambda, p1, alpha, p2, b1, b2, value, convcode) %>%
mutate(lambda = exp(lambda), p1 = exp(p1), alpha = exp(alpha), p2 = exp(p2), b1 = b1, b2 = b2) %>%
head(7)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(starts_with(c("lambda", "p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
if(is.null(opt.method)) {
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), data = data)
?optimx
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
if(is.null(opt.method)) {
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
} else {
if(!opt.method %in% c('Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', 'Rvmmin')) {
stop("not available method. Possible method codes at the time of writing are 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin'.")
}
opt <- optimx(par, ll, method = opt.method, hessian = TRUE, control = list(trace = 0))
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = "HI", data = data)
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = c("Nelder-Mead","nlminb"), data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
if(is.null(opt.method)) {
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
} else {
if(!any(opt.method %in% c('Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', 'Rvmmin'))) {
stop("Not available method. Possible method codes at the time of writing are 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin'.")
}
opt <- optimx(par, ll, method = opt.method, hessian = TRUE, control = list(trace = 0))
summary(opt)
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = "HI", data = data)
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = c("Nelder-Mead","nlminb"), data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + (-1)^protect * new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - (-1)^protect * new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
if(is.null(opt.method)) {
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
} else {
if(!any(opt.method %in% c('Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', 'Rvmmin'))) {
stop("Not available method. Possible method codes at the time of writing are 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin'.")
}
opt <- optimx(par, ll, method = opt.method, hessian = TRUE, control = list(trace = 0))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp))
}
}
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = c("Nelder-Mead","nlminb"), data = data)
mymodel(cbind(time, status) ~ x, time.scales = c("age"), opt.method = "nlminb", data = data)
mymodel(cbind(time, status) ~ x, time.scales = "age", data = data)
mymodel <- function(formula, data, time.scales, opt.method = NULL, protect = FALSE) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- (-1)^protect * new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -(-1)^protect * new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
if(is.null(opt.method)) {
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
} else {
if(!any(opt.method %in% c('Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', 'Rvmmin'))) {
stop("Not available method. Possible method codes at the time of writing are 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin'.")
}
opt <- optimx(par, ll, method = opt.method, hessian = TRUE, control = list(trace = 0))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp))
}
}
mymodel(cbind(time, status) ~ x, time.scales = "age", data = data, protect = T)
mymodel <- function(formula, data, time.scales, opt.method = NULL) {
Call <- match.call()
indx <- match(c("formula", "data"), names(Call), 0L)
temp <- Call[c(1L, indx)]
temp$drop.unused.levels <- TRUE
temp[[1L]] <- quote(stats::model.frame)
temp$formula <- terms(formula, data = data)
m <- eval(temp, parent.frame())
Terms <- attr(m, "terms")
Y <- model.extract(m, "response")
X <- model.matrix(Terms, m) %>% data.frame() %>% select(-1)
ts <- data[,time.scales] %>% as.data.frame()
colnames(ts) <- sapply(seq_along(time.scales), \(i) paste0("ts.", time.scales[[i]]))
n.ts <- ncol(ts) + 1
n.x <- ncol(X)
n.par <- 2 * n.ts + n.x * n.ts
ll <- function(par) {
new_par <- par
new_par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))] <- exp(par[c(seq(1, by = 2+n.x, len = n.ts), seq(2, by = 2+n.x, len = n.ts))]) # weibull parameter
tmp1 <- new_par[1] * new_par[2] * Y[Y[,2] == 1,1] ^ (new_par[2] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x])
tmp2 <- -new_par[1] * sum(Y[,1] ^ new_par[2] * exp(t(t(X)) %*% new_par[2+1:n.x]))
for(i in 1:(n.ts-1)) {
tmp1 <- tmp1 + new_par[1 + (2+n.x)*i] * new_par[2 + (2+n.x)*i] * (Y[Y[,2] == 1,1] + ts[Y[,2] == 1,i]) ^ (new_par[2 + (2+n.x)*i] - 1) * exp(t(t(X[Y[,2] == 1,])) %*% new_par[2+1:n.x+(2+n.x)*i])
tmp2 <- tmp2 - new_par[1 + (2+n.x)*i] * sum(((Y[,1] + ts[,i])^new_par[2 + (2+n.x)*i]-ts[,i]^new_par[2 + (2+n.x)*i]) * exp(t(t(X)) %*% new_par[2+1:n.x+(2+n.x)*i]))
}
return(-sum(log(tmp1))-tmp2)
}
par <- rep(0, n.par)
names(par) <- c(c("ts.prime.lambda", "ts.prime.p", sapply(1:n.x, \(j) paste0("ts.prime.", colnames(X)[j]))), sapply(2:n.ts, \(i) c(paste0(colnames(ts)[i-1], ".", "lambda"), paste0(colnames(ts)[i-1], ".", "p"), sapply(1:n.x, \(j) paste0(colnames(ts)[i-1], ".", colnames(X)[j])))))
if(is.null(opt.method)) {
opt <- optimx(par, ll, hessian = TRUE, control = list(trace = 0, all.methods = TRUE))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
filter(convcode != 9999) %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp)) %>%
head(7)
} else {
if(!any(opt.method %in% c('Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', 'Rvmmin'))) {
stop("Not available method. Possible method codes at the time of writing are 'Nelder-Mead', 'BFGS', 'CG', 'L-BFGS-B', 'nlm', 'nlminb', 'spg', 'ucminf', 'newuoa', 'bobyqa', 'nmkb', 'hjkb', 'Rcgmin', or 'Rvmmin'.")
}
opt <- optimx(par, ll, method = opt.method, hessian = TRUE, control = list(trace = 0))
summary(opt, order = "value") %>%
rownames_to_column("algorithm") %>%
arrange(value) %>%
select(algorithm, names(par), value, convcode) %>%
mutate(across(ends_with(c(".lambda", ".p")), exp))
}
}
